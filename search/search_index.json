{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"tsrc - managing groups of git repositories \u00b6 What it is \u00b6 tsrc is a command-line tool that helps you manage groups of git repositories. We use it at tanker.io because: We have a small, versatile team of developers We use several programming languages We need a single source of truth for the list of repositories we want to work on: their URL, branch and locations should be the same across all the team None on the many existing solutions did fully match our needs (see the FAQ for more details) Installing tsrc \u00b6 tsrc is compatible with Python 3.6 or higher. It is available on pypi and can be installed with pip : Linux \u00b6 $ pip3 install tsrc --user # Make sure ~/.local/bin is in your PATH macOS \u00b6 $ pip3 install tsrc --user # Make sure ~/Library/Python/3.x/bin is in your PATH Windows \u00b6 Install latest Python3 from python.org/downloads , open cmd.exe and run: $ pip3 install tsrc Next steps \u00b6 If tsrc is installed properly (check by running tsrc version ), feel free to proceed to basic usage .","title":"Home"},{"location":"#tsrc_-_managing_groups_of_git_repositories","text":"","title":"tsrc - managing groups of git repositories"},{"location":"#what_it_is","text":"tsrc is a command-line tool that helps you manage groups of git repositories. We use it at tanker.io because: We have a small, versatile team of developers We use several programming languages We need a single source of truth for the list of repositories we want to work on: their URL, branch and locations should be the same across all the team None on the many existing solutions did fully match our needs (see the FAQ for more details)","title":"What it is"},{"location":"#installing_tsrc","text":"tsrc is compatible with Python 3.6 or higher. It is available on pypi and can be installed with pip :","title":"Installing tsrc"},{"location":"#linux","text":"$ pip3 install tsrc --user # Make sure ~/.local/bin is in your PATH","title":"Linux"},{"location":"#macos","text":"$ pip3 install tsrc --user # Make sure ~/Library/Python/3.x/bin is in your PATH","title":"macOS"},{"location":"#windows","text":"Install latest Python3 from python.org/downloads , open cmd.exe and run: $ pip3 install tsrc","title":"Windows"},{"location":"#next_steps","text":"If tsrc is installed properly (check by running tsrc version ), feel free to proceed to basic usage .","title":"Next steps"},{"location":"changelog/","text":"Next release \u00b6 Remove codecov usage 2.2.1 (2021-04-10) \u00b6 Project has been moved from TankerHQ organization to dmerejkowsky . New urls are: github.com/dmerejkowsky/tsrc for the git repository dmerejkowsky.github.io/tsrc for the documentation Add CI jobs to check this project also works with Python 3.9 Drop Path Pie dependency Minor internal fixes Add more URLs in the metadata (and pypi.org project page) 2.2.0 (2020-07-17) \u00b6 Add symlink support \u00b6 tsrc sync and tsrc init can now create symlinks as specified in the manifest file: repos: - url: git@gitlab.local:proj1/app dest: app symlink: - source: app/some_file target: ../some_file In this case, a symlink will be created from <workspace>/app/some_file to <workspace>/some_file . (both source and target keys are relative to the repository's destination). Changes related to groups \u00b6 log, status, and sync all learned about the --group option and the --all-cloned options foreach: remove the --groups-from-config options since this is now the default behavior Misc \u00b6 Rework FAQ Run black in lint.sh Fix formatting of some messages Update code manifesto to suggest using docstrings in tests 2.1.0 (2020-05-27) \u00b6 Breaking changes \u00b6 Change in manifest syntax \u00b6 It was discovered that the manifest syntax was confusing for newcomers, so we decided to update it. In particular, the src key meant both a relative path in the workspace when used in the repo config, and a relative path in the a repository when using in the repo.copy config. Starting with this release, repo.src becomes repo.dest and repo.copy.src becomes repo.copy.file . # Before (tsrc < 2.1.0) repos: url: \"https://acme.corp/foo\" src: foo copy: src: some-file dest: some-file # After (tsrc >= 2.1.0) repos: url: \"https://acme.corp/foo\" dest : foo copy: file: some-file dest: some-file This should make it clearer what tsrc does because: dest now always refers to a relative path in the workspace (both in repo and copy ). By using repo.copy.file it's obvious that tsrc only supports copying files, not directories. Supported Python versions \u00b6 Drop support for Python 3.5 New features \u00b6 tsrc init learned a -r, --remote option that pins the remote with the given name as the only remote to be used for cloning and syncing. tsrc expects this remote to be present in the manifest for all repositories. This is useful if you use the same workspace in different physical locations, and one of the remotes is behind a VPN for instance. Patch by @tronje. Bug fixes \u00b6 Fix #217 : Preserves file attributes during the copy statements in repos Other \u00b6 The whole test suite now runs without errors on Windows - and Windows support is now part of the GitHub actions checks. The tests now run faster and with more readable output (this was done by using libgit2 instead of running git commands in the tests helpers). Add a scheduled GitHub action to run safety Remove usage of deprecated API of the path library. Run tests and linters for external pull requests too. v2.0.0 - (2020-04-06) \u00b6 Remove the tsrc push command and all review automation features. Please use hub , lab , or repo instead. See #207 for the discussion leading to this removal. Implement small improvements on tsrc output messages. Add tsrc apply-manifest , to apply changes in a manifest file locally, without having to make a commit and push to a server first. v1.0.3 - (2020-02-05) \u00b6 Use poetry for dependency management and packaging. v1.0.2 - (2020-01-29) \u00b6 Fix python_requires value in project metadata v1.0.1 - (2020-01-21) \u00b6 Fix #196: Do not attempt file copies for non-cloned repositories when using tsrc init with a list of groups. v1.0.0 - (2020-01-09) \u00b6 Starting the new year with a stable release, at last! Revamp group UX \u00b6 The changes below in the configuration file and command line syntax allow for better UX regarding groups. See the corresponding milestone for the full list. New configuration file \u00b6 Previously, tsrc stored its permanent configuration in .tsrc/manifest.yml and the file was not supposed to be edited by hand. Instead, users could use tsrc init to modify it, for instance with the --branch argument. Starting with this release, the command tsrc init can only be run once per workspace, and you must edit the .tsrc/config.yml file instead. Changes in command line syntax \u00b6 tsrc init : remove --file option. tsrc foreach : instead of repeating the --group option, you can use --groups with a list of groups: # before tsrc init --group foo --group bar # after tsrc init --groups foo bar tsrc init learned a --clone-all-repos option to clone all repositories from the manifest, regardless of the groups. Fix #181 Remove --file option from tsrc init . tsrc foreach learned a --groups-from-config option to use the groups configured in the workspace. Fix #178, #179. tsrc push learned a -o, --origin option to specify a remote name different from \"origin\". Fix #170 Other fixes \u00b6 Try and check that GitLab installation support required features before using them - typically, using tsrc push --approvers on GitLab Community Edition. (#165) reported by @irizzant. Switch to GitHub actions for running tests and linters. Also, publish documentation automatically when something is pushed to the master branch. tsrc status : add information when local branch does not match manifest configuration. (#190). Feature suggested by @janjachnick v0.9.2 - (2019-09-30) \u00b6 Additional bug fix for #165 - the fix in 0.9.1 was incomplete Improve error message when trying to use non-supported GitLab features (like using tsrc push --reviewer on GitLab Community Edition) v0.9.1 - (2019-09-23) \u00b6 Improve error message when tsrc foreach fails to start the process. Suggested by @dlewis-ald in #163 Fix crash when finding reviewers for a GitLab project not in a group. Reported by @irizzant in #165 v0.9.0 - (2019-08-13) \u00b6 Add support for GitHub Enterprise: patch by @sdavids13. Improve error message when using creating a merge request in a GitLab repository when the token cannot be found in the tsrc configuration file. Fix #158 Fix crash when running tsrc status on a workspace with missing repositories (#160) - reported by @blastrock v0.8.0 - (2019-08-12) \u00b6 Implement tsrc sync --force . Currently all it does is running git fetch --force on all repositories. Use with caution. See #152 for details. v0.7.1 - (2019-08-02) \u00b6 Fix crash in tsrc sync when the repo configuration in the manifest contained neither an URL nor a remote. tsrc now aborts as soon as the misconfiguration of the manifest is detected (Reported by @jongep86) v0.7.0 (2019-07-08) \u00b6 Add a --file option to tsrc init so that manifest can be read from a custom path in the file system Remove support for Python 3.4 Switch from xdg to pyxdg Format the code with black v0.6.6 (2019-04-02) \u00b6 Remove raw HTML from README.rst v0.6.5 (2019-04-0) \u00b6 Use codecov.io to measure coveage Prettify README v0.6.4 (2019-01-07) \u00b6 Remove support for Python 3.3. Use new and shiny cli-ui package instead of old python-cli-ui . v0.6.3 (2018-11-04) \u00b6 GitHub organization is now TankerHQ We now use dmenv for dependencies management v0.6.2 (2018-10-19) \u00b6 Fix crash when using tsrc push on a GitHub repository for the first time. v0.6.1 (2018-10-10) \u00b6 Fix weird output when configuring remotes. v0.6.0 (2018-10-09) \u00b6 Highlights \u00b6 Add support for multiple remotes \u00b6 # still valid (implicit 'origin' remote) src: foo url: git@github.com/foo # also valid (two explicit remotes) src: fooo remotes: - { name: origin, url: git@github.com:john/foo } - { name: upstream, url: git@github.com:foo/foo} # not valid (ambiguous) src: foo url: git@github.com:john/foo remotes: - { name: upstream, url: git@github.com:foo/foo } Thanks @tst2005 and @cgestes for their help with the configuration format. tsrc foreach \u00b6 tsrc foreach : add a --group option to select the repositories to run the command on. Fix #40 Other fixes \u00b6 Fix #113 : do not hide branch when showing tag status. Add support for Python 3.7 v0.5.0 (2018-08-14) \u00b6 Add support for setting approvers with the -r,--approvers option in tsrc push (GitLab Enterprise Edition only). v0.4.1 (2018-04-27) \u00b6 Fixed regression: tsrc push was no longer able to create a merge request on GitLab if --target was not set. v0.4.0 (2018-04-26) \u00b6 Highlights \u00b6 Preliminary GitHub support tsrc push : new features and bug fixes Improved fixed reference handling Support for shallow clones See below for the details. Preliminary GitHub support \u00b6 Added support for creating merge requests on GitHub. No configuration required. Just make sure you are using tsrc from a repository which has a URL starting with git@github.com . tsrc will prompt you once for your login and password and then store an API token. Afterwards, you'll be able to use tsrc push to: Create a pull request (or update it if it already exists) Assign people to the request (with the -a/--assignee option) Request reviewers (with the --reviewers option) Merge the pull request (with the --merge option) This change has no impact if you were already using GitLab . tsrc push : new features and bug fixes \u00b6 Add --close option. Breaking change : -m/--message option is gone, use --title instead. There's a concept of \"description\" or \"message\" for pull requests and merge requests, but the value of the option was only used to update the title , so it had to be renamed. Do not assume local and remote tracking branch have the same name. Allow using tsrc push <local>:<remote> to explicitly specify local and remote branch names. Fix bugs when target is not specified on the command line. See this commit for details. Fix missing merge requests in tsrc push (see issue #80 ). Patch by @maximerety. Improve fixed reference handling \u00b6 Breaking change : Instead of using fixed_ref in the manifest, you should now use tag or sha1 : old : repos: - src: git@example.com/foo fixed_ref: 42a70 new : repos: - src: git@example.com/foo tag: v0.1 See the dedicated section about manifest format and the #57 pull request discussion for the details. This allow us to implement different behaviors depending on whether or not the fixed ref is a tag or just a sha1. Support for shallow clones \u00b6 To save time and space, you can use tsrc init --shallow to only have shallow clones in your workspace. Note that due to limitations in git itself, the shallow option cannot be used with a fixed SHA1. If you need this, prefer using a tag instead. Misc \u00b6 Organization TankerApp was renamed to TankerHQ . New urls are: github.com/TankerHQ/tsrc for the git repository TankerHQ.github.io/tsrc for the documentation We now use pipenv for dependency handling. v0.3.2 (2017-11-02) \u00b6 Improve tsrc status to handle tags. Patch by @arnaudgelas. Fix crash when running tsrc version . v0.3.1 (2017-10-06) \u00b6 Improve tsrc status output. Now also shows number of commits ahead and behind, and display a short SHA-1 when not on any branch. Initial patch by @arnaudgelas. v0.3.0 (2017-09-22) \u00b6 Breaking change : Add support for groups (#30). Reported by @arnaudgelas. See the dedicated section about manifest format for details. Upgrading from v0.2.4 : To upgrade from an older version of tsrc , you should re-run tsrc init with the correct url: # Check manifest URL: $ cd <workspace>/.tsrc/manifest $ git remote get-url origin # Note the url, for instance ssh://git@example.com:manifest.git $ cd <workspace> $ tsrc init <manifest-url> This is required to create the <workspace>/.tsrc/manifest.yml file which is later used by tsrc sync and other commands. v0.2.4 (2017-07-13) \u00b6 tsrc push --assignee : fix when there are more than 50 GitLab users (#25). Reported by @arnaudgelas v0.2.3 (2017-09-01) \u00b6 Split user interface functionality into its own project: python-cli-ui . Add --quiet and --color global options. v0.2.2 (2017-08-22) \u00b6 Bug fix release. tsrc init : Fix crash when a repository is empty (#17). Reported by @nicolasbrechet tsrc push : Fix rude message when credentials are missing (#20). Reported by @cgestes v0.2.1 (2017-08-10) \u00b6 Packaging fixes. v0.2.0 (2017-08-09) \u00b6 Support for specifying custom branches in the manifest Support for specifying fixed refs (tags or hashes) in the manifest New syntax is: repos: - src: foo url: git@gitlab.com:proj/foo branch: next - src: bar url: git@gitlab.com:proj/bar branch: master fixed_ref: v0.1 Note that branch is still required. You can now skip the dest part of the copy section if src and dest are equal: copy: - src:foo # same thing as copy: - src: foo dest: foo v0.1.4 (2017-08-04) \u00b6 Support for Python 3.3, 3.4, 3.5 and 3.6 v0.1.1 (2017-08-02) \u00b6 First public release","title":"Changelog"},{"location":"changelog/#next_release","text":"Remove codecov usage","title":"Next release"},{"location":"changelog/#221_2021-04-10","text":"Project has been moved from TankerHQ organization to dmerejkowsky . New urls are: github.com/dmerejkowsky/tsrc for the git repository dmerejkowsky.github.io/tsrc for the documentation Add CI jobs to check this project also works with Python 3.9 Drop Path Pie dependency Minor internal fixes Add more URLs in the metadata (and pypi.org project page)","title":"2.2.1 (2021-04-10)"},{"location":"changelog/#220_2020-07-17","text":"","title":"2.2.0 (2020-07-17)"},{"location":"changelog/#add_symlink_support","text":"tsrc sync and tsrc init can now create symlinks as specified in the manifest file: repos: - url: git@gitlab.local:proj1/app dest: app symlink: - source: app/some_file target: ../some_file In this case, a symlink will be created from <workspace>/app/some_file to <workspace>/some_file . (both source and target keys are relative to the repository's destination).","title":"Add symlink support"},{"location":"changelog/#changes_related_to_groups","text":"log, status, and sync all learned about the --group option and the --all-cloned options foreach: remove the --groups-from-config options since this is now the default behavior","title":"Changes related to groups"},{"location":"changelog/#misc","text":"Rework FAQ Run black in lint.sh Fix formatting of some messages Update code manifesto to suggest using docstrings in tests","title":"Misc"},{"location":"changelog/#210_2020-05-27","text":"","title":"2.1.0 (2020-05-27)"},{"location":"changelog/#breaking_changes","text":"","title":"Breaking changes"},{"location":"changelog/#change_in_manifest_syntax","text":"It was discovered that the manifest syntax was confusing for newcomers, so we decided to update it. In particular, the src key meant both a relative path in the workspace when used in the repo config, and a relative path in the a repository when using in the repo.copy config. Starting with this release, repo.src becomes repo.dest and repo.copy.src becomes repo.copy.file . # Before (tsrc < 2.1.0) repos: url: \"https://acme.corp/foo\" src: foo copy: src: some-file dest: some-file # After (tsrc >= 2.1.0) repos: url: \"https://acme.corp/foo\" dest : foo copy: file: some-file dest: some-file This should make it clearer what tsrc does because: dest now always refers to a relative path in the workspace (both in repo and copy ). By using repo.copy.file it's obvious that tsrc only supports copying files, not directories.","title":"Change in manifest syntax"},{"location":"changelog/#supported_python_versions","text":"Drop support for Python 3.5","title":"Supported Python versions"},{"location":"changelog/#new_features","text":"tsrc init learned a -r, --remote option that pins the remote with the given name as the only remote to be used for cloning and syncing. tsrc expects this remote to be present in the manifest for all repositories. This is useful if you use the same workspace in different physical locations, and one of the remotes is behind a VPN for instance. Patch by @tronje.","title":"New features"},{"location":"changelog/#bug_fixes","text":"Fix #217 : Preserves file attributes during the copy statements in repos","title":"Bug fixes"},{"location":"changelog/#other","text":"The whole test suite now runs without errors on Windows - and Windows support is now part of the GitHub actions checks. The tests now run faster and with more readable output (this was done by using libgit2 instead of running git commands in the tests helpers). Add a scheduled GitHub action to run safety Remove usage of deprecated API of the path library. Run tests and linters for external pull requests too.","title":"Other"},{"location":"changelog/#v200_-_2020-04-06","text":"Remove the tsrc push command and all review automation features. Please use hub , lab , or repo instead. See #207 for the discussion leading to this removal. Implement small improvements on tsrc output messages. Add tsrc apply-manifest , to apply changes in a manifest file locally, without having to make a commit and push to a server first.","title":"v2.0.0 - (2020-04-06)"},{"location":"changelog/#v103_-_2020-02-05","text":"Use poetry for dependency management and packaging.","title":"v1.0.3 - (2020-02-05)"},{"location":"changelog/#v102_-_2020-01-29","text":"Fix python_requires value in project metadata","title":"v1.0.2 - (2020-01-29)"},{"location":"changelog/#v101_-_2020-01-21","text":"Fix #196: Do not attempt file copies for non-cloned repositories when using tsrc init with a list of groups.","title":"v1.0.1 - (2020-01-21)"},{"location":"changelog/#v100_-_2020-01-09","text":"Starting the new year with a stable release, at last!","title":"v1.0.0 - (2020-01-09)"},{"location":"changelog/#revamp_group_ux","text":"The changes below in the configuration file and command line syntax allow for better UX regarding groups. See the corresponding milestone for the full list.","title":"Revamp group UX"},{"location":"changelog/#new_configuration_file","text":"Previously, tsrc stored its permanent configuration in .tsrc/manifest.yml and the file was not supposed to be edited by hand. Instead, users could use tsrc init to modify it, for instance with the --branch argument. Starting with this release, the command tsrc init can only be run once per workspace, and you must edit the .tsrc/config.yml file instead.","title":"New configuration file"},{"location":"changelog/#changes_in_command_line_syntax","text":"tsrc init : remove --file option. tsrc foreach : instead of repeating the --group option, you can use --groups with a list of groups: # before tsrc init --group foo --group bar # after tsrc init --groups foo bar tsrc init learned a --clone-all-repos option to clone all repositories from the manifest, regardless of the groups. Fix #181 Remove --file option from tsrc init . tsrc foreach learned a --groups-from-config option to use the groups configured in the workspace. Fix #178, #179. tsrc push learned a -o, --origin option to specify a remote name different from \"origin\". Fix #170","title":"Changes in command line syntax"},{"location":"changelog/#other_fixes","text":"Try and check that GitLab installation support required features before using them - typically, using tsrc push --approvers on GitLab Community Edition. (#165) reported by @irizzant. Switch to GitHub actions for running tests and linters. Also, publish documentation automatically when something is pushed to the master branch. tsrc status : add information when local branch does not match manifest configuration. (#190). Feature suggested by @janjachnick","title":"Other fixes"},{"location":"changelog/#v092_-_2019-09-30","text":"Additional bug fix for #165 - the fix in 0.9.1 was incomplete Improve error message when trying to use non-supported GitLab features (like using tsrc push --reviewer on GitLab Community Edition)","title":"v0.9.2 - (2019-09-30)"},{"location":"changelog/#v091_-_2019-09-23","text":"Improve error message when tsrc foreach fails to start the process. Suggested by @dlewis-ald in #163 Fix crash when finding reviewers for a GitLab project not in a group. Reported by @irizzant in #165","title":"v0.9.1 - (2019-09-23)"},{"location":"changelog/#v090_-_2019-08-13","text":"Add support for GitHub Enterprise: patch by @sdavids13. Improve error message when using creating a merge request in a GitLab repository when the token cannot be found in the tsrc configuration file. Fix #158 Fix crash when running tsrc status on a workspace with missing repositories (#160) - reported by @blastrock","title":"v0.9.0 - (2019-08-13)"},{"location":"changelog/#v080_-_2019-08-12","text":"Implement tsrc sync --force . Currently all it does is running git fetch --force on all repositories. Use with caution. See #152 for details.","title":"v0.8.0 - (2019-08-12)"},{"location":"changelog/#v071_-_2019-08-02","text":"Fix crash in tsrc sync when the repo configuration in the manifest contained neither an URL nor a remote. tsrc now aborts as soon as the misconfiguration of the manifest is detected (Reported by @jongep86)","title":"v0.7.1 - (2019-08-02)"},{"location":"changelog/#v070_2019-07-08","text":"Add a --file option to tsrc init so that manifest can be read from a custom path in the file system Remove support for Python 3.4 Switch from xdg to pyxdg Format the code with black","title":"v0.7.0 (2019-07-08)"},{"location":"changelog/#v066_2019-04-02","text":"Remove raw HTML from README.rst","title":"v0.6.6 (2019-04-02)"},{"location":"changelog/#v065_2019-04-0","text":"Use codecov.io to measure coveage Prettify README","title":"v0.6.5 (2019-04-0)"},{"location":"changelog/#v064_2019-01-07","text":"Remove support for Python 3.3. Use new and shiny cli-ui package instead of old python-cli-ui .","title":"v0.6.4 (2019-01-07)"},{"location":"changelog/#v063_2018-11-04","text":"GitHub organization is now TankerHQ We now use dmenv for dependencies management","title":"v0.6.3 (2018-11-04)"},{"location":"changelog/#v062_2018-10-19","text":"Fix crash when using tsrc push on a GitHub repository for the first time.","title":"v0.6.2 (2018-10-19)"},{"location":"changelog/#v061_2018-10-10","text":"Fix weird output when configuring remotes.","title":"v0.6.1 (2018-10-10)"},{"location":"changelog/#v060_2018-10-09","text":"","title":"v0.6.0 (2018-10-09)"},{"location":"changelog/#highlights","text":"","title":"Highlights"},{"location":"changelog/#add_support_for_multiple_remotes","text":"# still valid (implicit 'origin' remote) src: foo url: git@github.com/foo # also valid (two explicit remotes) src: fooo remotes: - { name: origin, url: git@github.com:john/foo } - { name: upstream, url: git@github.com:foo/foo} # not valid (ambiguous) src: foo url: git@github.com:john/foo remotes: - { name: upstream, url: git@github.com:foo/foo } Thanks @tst2005 and @cgestes for their help with the configuration format.","title":"Add support for multiple remotes"},{"location":"changelog/#tsrc_foreach","text":"tsrc foreach : add a --group option to select the repositories to run the command on. Fix #40","title":"tsrc foreach"},{"location":"changelog/#other_fixes_1","text":"Fix #113 : do not hide branch when showing tag status. Add support for Python 3.7","title":"Other fixes"},{"location":"changelog/#v050_2018-08-14","text":"Add support for setting approvers with the -r,--approvers option in tsrc push (GitLab Enterprise Edition only).","title":"v0.5.0 (2018-08-14)"},{"location":"changelog/#v041_2018-04-27","text":"Fixed regression: tsrc push was no longer able to create a merge request on GitLab if --target was not set.","title":"v0.4.1 (2018-04-27)"},{"location":"changelog/#v040_2018-04-26","text":"","title":"v0.4.0 (2018-04-26)"},{"location":"changelog/#highlights_1","text":"Preliminary GitHub support tsrc push : new features and bug fixes Improved fixed reference handling Support for shallow clones See below for the details.","title":"Highlights"},{"location":"changelog/#preliminary_github_support","text":"Added support for creating merge requests on GitHub. No configuration required. Just make sure you are using tsrc from a repository which has a URL starting with git@github.com . tsrc will prompt you once for your login and password and then store an API token. Afterwards, you'll be able to use tsrc push to: Create a pull request (or update it if it already exists) Assign people to the request (with the -a/--assignee option) Request reviewers (with the --reviewers option) Merge the pull request (with the --merge option) This change has no impact if you were already using GitLab .","title":"Preliminary GitHub support"},{"location":"changelog/#tsrc_push_new_features_and_bug_fixes","text":"Add --close option. Breaking change : -m/--message option is gone, use --title instead. There's a concept of \"description\" or \"message\" for pull requests and merge requests, but the value of the option was only used to update the title , so it had to be renamed. Do not assume local and remote tracking branch have the same name. Allow using tsrc push <local>:<remote> to explicitly specify local and remote branch names. Fix bugs when target is not specified on the command line. See this commit for details. Fix missing merge requests in tsrc push (see issue #80 ). Patch by @maximerety.","title":"tsrc push: new features and bug fixes"},{"location":"changelog/#improve_fixed_reference_handling","text":"Breaking change : Instead of using fixed_ref in the manifest, you should now use tag or sha1 : old : repos: - src: git@example.com/foo fixed_ref: 42a70 new : repos: - src: git@example.com/foo tag: v0.1 See the dedicated section about manifest format and the #57 pull request discussion for the details. This allow us to implement different behaviors depending on whether or not the fixed ref is a tag or just a sha1.","title":"Improve fixed reference handling"},{"location":"changelog/#support_for_shallow_clones","text":"To save time and space, you can use tsrc init --shallow to only have shallow clones in your workspace. Note that due to limitations in git itself, the shallow option cannot be used with a fixed SHA1. If you need this, prefer using a tag instead.","title":"Support for shallow clones"},{"location":"changelog/#misc_1","text":"Organization TankerApp was renamed to TankerHQ . New urls are: github.com/TankerHQ/tsrc for the git repository TankerHQ.github.io/tsrc for the documentation We now use pipenv for dependency handling.","title":"Misc"},{"location":"changelog/#v032_2017-11-02","text":"Improve tsrc status to handle tags. Patch by @arnaudgelas. Fix crash when running tsrc version .","title":"v0.3.2 (2017-11-02)"},{"location":"changelog/#v031_2017-10-06","text":"Improve tsrc status output. Now also shows number of commits ahead and behind, and display a short SHA-1 when not on any branch. Initial patch by @arnaudgelas.","title":"v0.3.1 (2017-10-06)"},{"location":"changelog/#v030_2017-09-22","text":"Breaking change : Add support for groups (#30). Reported by @arnaudgelas. See the dedicated section about manifest format for details. Upgrading from v0.2.4 : To upgrade from an older version of tsrc , you should re-run tsrc init with the correct url: # Check manifest URL: $ cd <workspace>/.tsrc/manifest $ git remote get-url origin # Note the url, for instance ssh://git@example.com:manifest.git $ cd <workspace> $ tsrc init <manifest-url> This is required to create the <workspace>/.tsrc/manifest.yml file which is later used by tsrc sync and other commands.","title":"v0.3.0 (2017-09-22)"},{"location":"changelog/#v024_2017-07-13","text":"tsrc push --assignee : fix when there are more than 50 GitLab users (#25). Reported by @arnaudgelas","title":"v0.2.4 (2017-07-13)"},{"location":"changelog/#v023_2017-09-01","text":"Split user interface functionality into its own project: python-cli-ui . Add --quiet and --color global options.","title":"v0.2.3 (2017-09-01)"},{"location":"changelog/#v022_2017-08-22","text":"Bug fix release. tsrc init : Fix crash when a repository is empty (#17). Reported by @nicolasbrechet tsrc push : Fix rude message when credentials are missing (#20). Reported by @cgestes","title":"v0.2.2 (2017-08-22)"},{"location":"changelog/#v021_2017-08-10","text":"Packaging fixes.","title":"v0.2.1 (2017-08-10)"},{"location":"changelog/#v020_2017-08-09","text":"Support for specifying custom branches in the manifest Support for specifying fixed refs (tags or hashes) in the manifest New syntax is: repos: - src: foo url: git@gitlab.com:proj/foo branch: next - src: bar url: git@gitlab.com:proj/bar branch: master fixed_ref: v0.1 Note that branch is still required. You can now skip the dest part of the copy section if src and dest are equal: copy: - src:foo # same thing as copy: - src: foo dest: foo","title":"v0.2.0 (2017-08-09)"},{"location":"changelog/#v014_2017-08-04","text":"Support for Python 3.3, 3.4, 3.5 and 3.6","title":"v0.1.4 (2017-08-04)"},{"location":"changelog/#v011_2017-08-02","text":"First public release","title":"v0.1.1 (2017-08-02)"},{"location":"code-manifesto/","text":"Basics \u00b6 We use black to enforce a coding style matching PEP8 . In addition, every text file must be pushed using UNIX line endings. (On Windows, you are advised to set core.autocrlf to true in your git config file.) Pet peeves \u00b6 Prefer double quotes for string literals: # Yes def bar(): \"\"\" bar stuff \"\"\" a = \"foo\" # No def bar(): ''' bar stuff ''' a = 'foo' # Exception my_str = 'It contains some \"quotes\" inside' Use the fact that empty data structures are falsy: # Yes if not errors: ... # No if len(errors) == 0: ... Avoid using double negatives: # Yes def make_coffee(sugar=False): if sugar: print(\"with sugar\") # No def make_coffee(without_sugar=True): if not without_sugar: print(\"with sugar\") Prefer using \"f-strings\" if possible, + may also work in some contexts. # Yes message = f\"Welcome {name}!\" # No message = \"Welcome, {}!\".format(name) message = \"Welcome, %s!\" % name message = \"Welcome, \" + name + \"!\" # Okayish with_ext = name + \".txt\" Use textwrap.dedent() to build nice-looking multi-lines strings: # Yes def foo(): long_message = textwrap.dedent(\"\"\"\\ first line second line third line\"\"\") # No def foo(): long_message = \"\"\"\\ first line second line third line \"\"\" Do not initialize several variables on the same line, unless they come from a tuple (for instance the return of a function, or a iteration on a directory) # Yes ok, mess = run_command() for test_result in test_results: outcome, message = res # No foo, bar = False, \"\" class Foo: self.bar, self.baz = None, True Do not use conditional expressions. The order is not the same as the ternary operator in C++ and JavaScript, so it should be avoided: # Yes if foo: a = \"ok\" else: a = \"nope\" # No: a = \"ok\" if foo else \"nope\" Use if ... in ... when you can: # Yes if value in [\"option1\", \"option2\"]: ... # No if value == \"option1\" or value == \"option2\" ... Doc strings and comments in production code \u00b6 First off, bad comments are worse that no comments. Also note that you should use comments to explain why , never what . If the what is no clear, it means the behavior of the function or method cannot be easily understood by reading implementation, and so you should fix the implementation instead. In conclusion, use comments and doc strings sparingly: that way, they will not rot and they will stay useful. Note: this does not apply for tests (see below). Collections \u00b6 Use .extend() instead of += to concatenate lists: # Yes list_1.extend(list_2) # No list_1 += list_2 Only use list() and dict() to convert a value to a list or dict. Prefer literals when possible # Yes my_list = [] my_dict = {} # Also yes: my_list = list(yield_stuff()) # No my_list = list() my_dict = dict() Also use explicit call to list() in order to make a copy: # Yes my_copy = list(my_list) # Also yes: my_copy = copy.copy(my_list) # No my_copy = my_list[:] Use list comprehensions instead of loops and \"functional\" methods: # Yes my_list = [foo(x) for x in other_list] # No my_list = list() for x in other_list: x.append(foo(x)) # Also no my_list = map(foo, other_list) # Yes even_nums = [x for x in nums if is_even(x)] # No even_nums = filter(is_even, nums) Use iterable syntax instead of building an explicit list: # Yes max(len(x) for x in my_iterable) # No max([len(x) for x in my_iterable]) Use plural names for collections. This has the nice benefit of allowing you to have meaningful loop names: for result in results: # do something with result Functions \u00b6 Prefer using keyword-only parameters when possible: # Yes # If the parameter needs a default value: def foo(bar, *, spam=True): ... # If it does not: def foo(bar, *, spam): ... # No def foo(bar, spam=True): ... If you use the last form, Python will let you use foo(42, False) , and set spam to False. This can cause problems if someone ever changes the foo function and adds a new optional argument before spam : def foo(bar, eggs=False, spam=Tue): ... After such a change, the line foo(42, False) which used to call foo with spam=False now calls foo with bar=False and spam=True , leading to all kinds of interesting bugs. Exception to this rule: when the keyword is obvious and will not change: def get(value, default=None): ... Imports \u00b6 For any foo.py file, import foo must never fail, unless there is a necessary module that could not be found. Do not catch ImportError unless it is necessary, for instance to deal with optional dependencies. import required_module HAS_NICE_FEATURE = True try: import nice_lib except ImportError: HAS_NICE_FEATURE = False #... if HAS_NICE_FEATURE: #.... Importing Python files should never cause side effects. It's OK to initialize global variables, but you should never call functions outside a if __name__ == main() block . Prefer using fully-qualified imports and names: # Yes import foo.bar my_bar = foo.bar.Bar() # No from foo import bar my_bar = bar.Bar() Note We allow a few exceptions like from pathlib import Path or importing classes directory in tests. Use your best judgment. Classes \u00b6 When you want to make sure a class follows an interface, use abc.ABCMeta instead of raising NotImplementedError . This way you get the error when the class is instantiated instead of when the method is called. # Yes class AbstractFoo(metaclass=abc.ABCMeta): @abc.abstractmethod def foo(self): pass # No class AbstractFoo: def foo(self): raise NotImplementedError() Make sure to use properties when relevant, instead of get_ methods. # Yes class Person: def __init__(self, first_name, last_name): self.first_name = first_name self.last_name = last_name @property def full_name(self): return f\"{self.first_name} {self.last_name}\" # No: class Foo: def __init__(self, first_name, last_name): self.first_name = first_name self.last_name = last_name self.full_name = f\"{self.first_name} {self.last_name}\" For instance, here: full_name is read-only The attribute is automatically updated if first_name changes after the object is initialized. Note that get_ methods are OK if they do more than simple computations (expensive in time or size, throwing exceptions ...) File paths \u00b6 If you are manipulating filenames, use the path.py library and suffix the variable by _path . Avoid using os.path or shutil methods when path.py is better. # Yes work_path = Path(\"foo/work\") work_path.mkdir_p() foo_path = work_path / \"foo.txt\" foo_path.write_text(\"this is bar\") # No work_path = os.path.join(foo, \"work\") os.path.mkdir(work_path, exist_ok=True) foo_path = os.path.join(work_path, \"foo.txt\") with open(foo_path, \"w\") as fileobj: fileobj.write(\"this is foo\") Error handling \u00b6 All exceptions raised from within tsrc should derive from tsrc.Error . When using external code (from the standard library or a third-party library), you should catch the exceptions and optionally re-raise them. Output messages to the user \u00b6 Do not use print , use python-cli-ui functions instead. This makes it easier to distinguish between real messages and the throw-away print statements you add for debugging. Also, using \"high-level\" methods such as ui.info_1() or ui.warning() will make it easier to have a consistent user interface. Tests \u00b6 Docstrings \u00b6 If you think the test implementation is complex, add a human-readable description of the test scenario in the doc string. For instance: def test_sync_with_errors(...): \"\"\"\" Scenario: * Create a manifest with two repos (foo and bar) * Initialize a workspace from this manifest * Push a new file to the foo repo * Create a merge conflict in the foo repo * Run `tsrc sync` * Check that the command fails and produces the proper error message \"\"\" Assertions with lists \u00b6 Use tuple unpacking to write shorter assertions: # Yes actual_list = function_that_returns_list() (first, second) = actual_list assert first == something assert second == something_else # NO actual_list = function_that_returns_list() assert len(actual_list) == 2 first = actual_list[0] second = actual_list[1] assert first == something assert second == something_else Assertion order \u00b6 When writing assertions, use the form assert <actual> == <expected> : # Yes def test_foo(): assert foo(42) == True def test_big_stuff(): actual_result = ... expected_result = ... assert actual_result == expected_result # No def test_foo(): assert True == foo(42) def test_big_stuff(): actual_result = ... expected_result = ... assert expected_result == actual_result Rationale: The assert(expected, actual) convention comes from JUnit but we are not writing Java code, and besides, the assert(actual, expected) convention also exists in other tools. pytest does not really care, but we prefer being consistent in all tests. It's a bit closer to what you would say in English: \"Assert that the result of foo() is 42\" .","title":"Code manifesto"},{"location":"code-manifesto/#basics","text":"We use black to enforce a coding style matching PEP8 . In addition, every text file must be pushed using UNIX line endings. (On Windows, you are advised to set core.autocrlf to true in your git config file.)","title":"Basics"},{"location":"code-manifesto/#pet_peeves","text":"Prefer double quotes for string literals: # Yes def bar(): \"\"\" bar stuff \"\"\" a = \"foo\" # No def bar(): ''' bar stuff ''' a = 'foo' # Exception my_str = 'It contains some \"quotes\" inside' Use the fact that empty data structures are falsy: # Yes if not errors: ... # No if len(errors) == 0: ... Avoid using double negatives: # Yes def make_coffee(sugar=False): if sugar: print(\"with sugar\") # No def make_coffee(without_sugar=True): if not without_sugar: print(\"with sugar\") Prefer using \"f-strings\" if possible, + may also work in some contexts. # Yes message = f\"Welcome {name}!\" # No message = \"Welcome, {}!\".format(name) message = \"Welcome, %s!\" % name message = \"Welcome, \" + name + \"!\" # Okayish with_ext = name + \".txt\" Use textwrap.dedent() to build nice-looking multi-lines strings: # Yes def foo(): long_message = textwrap.dedent(\"\"\"\\ first line second line third line\"\"\") # No def foo(): long_message = \"\"\"\\ first line second line third line \"\"\" Do not initialize several variables on the same line, unless they come from a tuple (for instance the return of a function, or a iteration on a directory) # Yes ok, mess = run_command() for test_result in test_results: outcome, message = res # No foo, bar = False, \"\" class Foo: self.bar, self.baz = None, True Do not use conditional expressions. The order is not the same as the ternary operator in C++ and JavaScript, so it should be avoided: # Yes if foo: a = \"ok\" else: a = \"nope\" # No: a = \"ok\" if foo else \"nope\" Use if ... in ... when you can: # Yes if value in [\"option1\", \"option2\"]: ... # No if value == \"option1\" or value == \"option2\" ...","title":"Pet peeves"},{"location":"code-manifesto/#doc_strings_and_comments_in_production_code","text":"First off, bad comments are worse that no comments. Also note that you should use comments to explain why , never what . If the what is no clear, it means the behavior of the function or method cannot be easily understood by reading implementation, and so you should fix the implementation instead. In conclusion, use comments and doc strings sparingly: that way, they will not rot and they will stay useful. Note: this does not apply for tests (see below).","title":"Doc strings and comments in production code"},{"location":"code-manifesto/#collections","text":"Use .extend() instead of += to concatenate lists: # Yes list_1.extend(list_2) # No list_1 += list_2 Only use list() and dict() to convert a value to a list or dict. Prefer literals when possible # Yes my_list = [] my_dict = {} # Also yes: my_list = list(yield_stuff()) # No my_list = list() my_dict = dict() Also use explicit call to list() in order to make a copy: # Yes my_copy = list(my_list) # Also yes: my_copy = copy.copy(my_list) # No my_copy = my_list[:] Use list comprehensions instead of loops and \"functional\" methods: # Yes my_list = [foo(x) for x in other_list] # No my_list = list() for x in other_list: x.append(foo(x)) # Also no my_list = map(foo, other_list) # Yes even_nums = [x for x in nums if is_even(x)] # No even_nums = filter(is_even, nums) Use iterable syntax instead of building an explicit list: # Yes max(len(x) for x in my_iterable) # No max([len(x) for x in my_iterable]) Use plural names for collections. This has the nice benefit of allowing you to have meaningful loop names: for result in results: # do something with result","title":"Collections"},{"location":"code-manifesto/#functions","text":"Prefer using keyword-only parameters when possible: # Yes # If the parameter needs a default value: def foo(bar, *, spam=True): ... # If it does not: def foo(bar, *, spam): ... # No def foo(bar, spam=True): ... If you use the last form, Python will let you use foo(42, False) , and set spam to False. This can cause problems if someone ever changes the foo function and adds a new optional argument before spam : def foo(bar, eggs=False, spam=Tue): ... After such a change, the line foo(42, False) which used to call foo with spam=False now calls foo with bar=False and spam=True , leading to all kinds of interesting bugs. Exception to this rule: when the keyword is obvious and will not change: def get(value, default=None): ...","title":"Functions"},{"location":"code-manifesto/#imports","text":"For any foo.py file, import foo must never fail, unless there is a necessary module that could not be found. Do not catch ImportError unless it is necessary, for instance to deal with optional dependencies. import required_module HAS_NICE_FEATURE = True try: import nice_lib except ImportError: HAS_NICE_FEATURE = False #... if HAS_NICE_FEATURE: #.... Importing Python files should never cause side effects. It's OK to initialize global variables, but you should never call functions outside a if __name__ == main() block . Prefer using fully-qualified imports and names: # Yes import foo.bar my_bar = foo.bar.Bar() # No from foo import bar my_bar = bar.Bar() Note We allow a few exceptions like from pathlib import Path or importing classes directory in tests. Use your best judgment.","title":"Imports"},{"location":"code-manifesto/#classes","text":"When you want to make sure a class follows an interface, use abc.ABCMeta instead of raising NotImplementedError . This way you get the error when the class is instantiated instead of when the method is called. # Yes class AbstractFoo(metaclass=abc.ABCMeta): @abc.abstractmethod def foo(self): pass # No class AbstractFoo: def foo(self): raise NotImplementedError() Make sure to use properties when relevant, instead of get_ methods. # Yes class Person: def __init__(self, first_name, last_name): self.first_name = first_name self.last_name = last_name @property def full_name(self): return f\"{self.first_name} {self.last_name}\" # No: class Foo: def __init__(self, first_name, last_name): self.first_name = first_name self.last_name = last_name self.full_name = f\"{self.first_name} {self.last_name}\" For instance, here: full_name is read-only The attribute is automatically updated if first_name changes after the object is initialized. Note that get_ methods are OK if they do more than simple computations (expensive in time or size, throwing exceptions ...)","title":"Classes"},{"location":"code-manifesto/#file_paths","text":"If you are manipulating filenames, use the path.py library and suffix the variable by _path . Avoid using os.path or shutil methods when path.py is better. # Yes work_path = Path(\"foo/work\") work_path.mkdir_p() foo_path = work_path / \"foo.txt\" foo_path.write_text(\"this is bar\") # No work_path = os.path.join(foo, \"work\") os.path.mkdir(work_path, exist_ok=True) foo_path = os.path.join(work_path, \"foo.txt\") with open(foo_path, \"w\") as fileobj: fileobj.write(\"this is foo\")","title":"File paths"},{"location":"code-manifesto/#error_handling","text":"All exceptions raised from within tsrc should derive from tsrc.Error . When using external code (from the standard library or a third-party library), you should catch the exceptions and optionally re-raise them.","title":"Error handling"},{"location":"code-manifesto/#output_messages_to_the_user","text":"Do not use print , use python-cli-ui functions instead. This makes it easier to distinguish between real messages and the throw-away print statements you add for debugging. Also, using \"high-level\" methods such as ui.info_1() or ui.warning() will make it easier to have a consistent user interface.","title":"Output messages to the user"},{"location":"code-manifesto/#tests","text":"","title":"Tests"},{"location":"code-manifesto/#docstrings","text":"If you think the test implementation is complex, add a human-readable description of the test scenario in the doc string. For instance: def test_sync_with_errors(...): \"\"\"\" Scenario: * Create a manifest with two repos (foo and bar) * Initialize a workspace from this manifest * Push a new file to the foo repo * Create a merge conflict in the foo repo * Run `tsrc sync` * Check that the command fails and produces the proper error message \"\"\"","title":"Docstrings"},{"location":"code-manifesto/#assertions_with_lists","text":"Use tuple unpacking to write shorter assertions: # Yes actual_list = function_that_returns_list() (first, second) = actual_list assert first == something assert second == something_else # NO actual_list = function_that_returns_list() assert len(actual_list) == 2 first = actual_list[0] second = actual_list[1] assert first == something assert second == something_else","title":"Assertions with lists"},{"location":"code-manifesto/#assertion_order","text":"When writing assertions, use the form assert <actual> == <expected> : # Yes def test_foo(): assert foo(42) == True def test_big_stuff(): actual_result = ... expected_result = ... assert actual_result == expected_result # No def test_foo(): assert True == foo(42) def test_big_stuff(): actual_result = ... expected_result = ... assert expected_result == actual_result Rationale: The assert(expected, actual) convention comes from JUnit but we are not writing Java code, and besides, the assert(actual, expected) convention also exists in other tools. pytest does not really care, but we prefer being consistent in all tests. It's a bit closer to what you would say in English: \"Assert that the result of foo() is 42\" .","title":"Assertion order"},{"location":"contrib/","text":"Development \u00b6 All the development happens on GitHub . Reporting bugs and suggesting new features \u00b6 Feel free to use the GitHub's bug tracker to open issues. If you are reporting a bug, please provide the following information: tsrc version Details about your environment (operating system, Python version) The exact command you run The full output Doing so will ensure we can investigate your bug right away. Suggesting changes \u00b6 You are free to open a pull request on GitHub for any feature you'd like. Before opening a merge request, please read the code manifesto . Note that for your merge request to be accepted, we'll ask that: You follow indications from the code manifesto All existing linters pass All existing tests run The new feature comes with appropriate tests See the GitHub actions workflows to see what exactly what commands are run and the Python versions we support. Also, if relevant, you will need to: update the changelog (in docs/changelog.md ) update the documentation if required Finally, feel free to add your name in the THANKS file ;) Checking your changes \u00b6 Install latest poetry version. Install development and documentation dependencies: $ poetry install Run linters and tests: $ poetry run invoke lint $ poetry run pytest -n auto Adding documentation \u00b6 Follow the steps from the above section to setup your python environment Launch the development server locally: $ poetry run mkdocs serve Edit the markdown files from the docs/ folder and review the changes in your browser Finally, submit your changes by opening a pull request on GitHub","title":"Contributing"},{"location":"contrib/#development","text":"All the development happens on GitHub .","title":"Development"},{"location":"contrib/#reporting_bugs_and_suggesting_new_features","text":"Feel free to use the GitHub's bug tracker to open issues. If you are reporting a bug, please provide the following information: tsrc version Details about your environment (operating system, Python version) The exact command you run The full output Doing so will ensure we can investigate your bug right away.","title":"Reporting bugs and suggesting new features"},{"location":"contrib/#suggesting_changes","text":"You are free to open a pull request on GitHub for any feature you'd like. Before opening a merge request, please read the code manifesto . Note that for your merge request to be accepted, we'll ask that: You follow indications from the code manifesto All existing linters pass All existing tests run The new feature comes with appropriate tests See the GitHub actions workflows to see what exactly what commands are run and the Python versions we support. Also, if relevant, you will need to: update the changelog (in docs/changelog.md ) update the documentation if required Finally, feel free to add your name in the THANKS file ;)","title":"Suggesting changes"},{"location":"contrib/#checking_your_changes","text":"Install latest poetry version. Install development and documentation dependencies: $ poetry install Run linters and tests: $ poetry run invoke lint $ poetry run pytest -n auto","title":"Checking your changes"},{"location":"contrib/#adding_documentation","text":"Follow the steps from the above section to setup your python environment Launch the development server locally: $ poetry run mkdocs serve Edit the markdown files from the docs/ folder and review the changes in your browser Finally, submit your changes by opening a pull request on GitHub","title":"Adding documentation"},{"location":"faq/","text":"Why not repo? \u00b6 We used repo for a while, but found that tsrc had both a better command line API and a nicer output. On a less subjective level: Good support for Windows (no need for Cygwin or anything like that) Also, tsrc tries hard to never do any destructive operation or unexpected actions. For instance, tsrc never puts you in a \"detached HEAD\" state, nor does automatic rebase. It also never touches dirty repositories. This is achieved by using mostly 'porcelain' commands from git, instead of relying on plumbings internals. Also (and this matters a lot if you think about contribution): Uses PEP8 coding style, enforced with black Comprehensive test suite Fully type-checked with mypy Note that there are a few features present in repo that are missing from tsrc (but may be implemented in the future). Feel free to open a feature request if needed! Why not git-subrepo, mu-repo, or gr? \u00b6 All this projects are fine but did not match our needs: git-subrepo squashes commits, and we prefer having normal clones everywhere. mu-repo is nice and contains an interesting dependency management feature, but currently we do not need this complexity. In any case, now that the whole team is using tsrc all the time, it's likely we'll keep using tsrc in the future. Why not git submodule? \u00b6 It's all about workflow. With git-submodule , you have a 'parent' repository and you freeze the state of the 'children' repositories to a specific commit. It's useful when you want to re-build a library you've forked when you build your main project, or when you have a library or build tools you want to factorize across repositories: this means that each 'parent' repository can have its children on any commit they want. With tsrc , all repositories are equal, and what you do instead is to make sure all the branches (or tags) are consistent across repositories. For instance, if you have foo and bar , you are going to make sure the 'master' branch of foo is always compatible to the 'master' branch of bar . Or if you want to go back to the state of the '0.42' release, you will run: tsrc foreach -- git reset --hard v0.42 . Note that since tsrc 0.2 you can also freeze the commits of some of the repositories. Last but not least, with tsrc you do everything with commands like tsrc init and tsrc sync , or simple yaml files, which is much easier than using the git submodule CLI. Why not using pygit2 or similar instead of running git commands? \u00b6 First off, we do use pygit2 , but only for tests. Second, the pygit2 package depends on a 3rd party C library ( libgit2 ) - and that can cause problems in certain cases. If we can, we prefer using pure-Python libraries for the production code. Finally, we prefer calling git \"porcelain\" commands, both for readability of the source code and ease of debugging (see below). Why do you hide which git commands are run? \u00b6 It's mainly a matter of not cluttering the output. We take care of keeping the output of tsrc both concise, readable and informative. That being said: In case a git command fails, we'll display the full command that was run. If you still need to see all the git commands that are run, we provide a --verbose flag, like so: tsrc --verbose sync Why argh? \u00b6 Because we need (almost) all of argparse features, but still want to keep the code DRY. Why YAML? \u00b6 It's nice to read and write, and we use the excellent ruamel.yaml which even has round-trip support. Also, being Python fans, we don't mind that white space is part of the syntax. Why do I have to create a separate git repo with just one file in it? \u00b6 See #235 for why you can't have multiple manifest files in the same repository. Also, note that you can put other files in the repo - for instance, add a CI script that verifies the yaml syntax and checks that all the repos in the manifest can be cloned.","title":"FAQ"},{"location":"faq/#why_not_repo","text":"We used repo for a while, but found that tsrc had both a better command line API and a nicer output. On a less subjective level: Good support for Windows (no need for Cygwin or anything like that) Also, tsrc tries hard to never do any destructive operation or unexpected actions. For instance, tsrc never puts you in a \"detached HEAD\" state, nor does automatic rebase. It also never touches dirty repositories. This is achieved by using mostly 'porcelain' commands from git, instead of relying on plumbings internals. Also (and this matters a lot if you think about contribution): Uses PEP8 coding style, enforced with black Comprehensive test suite Fully type-checked with mypy Note that there are a few features present in repo that are missing from tsrc (but may be implemented in the future). Feel free to open a feature request if needed!","title":"Why not repo?"},{"location":"faq/#why_not_git-subrepo_mu-repo_or_gr","text":"All this projects are fine but did not match our needs: git-subrepo squashes commits, and we prefer having normal clones everywhere. mu-repo is nice and contains an interesting dependency management feature, but currently we do not need this complexity. In any case, now that the whole team is using tsrc all the time, it's likely we'll keep using tsrc in the future.","title":"Why not git-subrepo, mu-repo, or gr?"},{"location":"faq/#why_not_git_submodule","text":"It's all about workflow. With git-submodule , you have a 'parent' repository and you freeze the state of the 'children' repositories to a specific commit. It's useful when you want to re-build a library you've forked when you build your main project, or when you have a library or build tools you want to factorize across repositories: this means that each 'parent' repository can have its children on any commit they want. With tsrc , all repositories are equal, and what you do instead is to make sure all the branches (or tags) are consistent across repositories. For instance, if you have foo and bar , you are going to make sure the 'master' branch of foo is always compatible to the 'master' branch of bar . Or if you want to go back to the state of the '0.42' release, you will run: tsrc foreach -- git reset --hard v0.42 . Note that since tsrc 0.2 you can also freeze the commits of some of the repositories. Last but not least, with tsrc you do everything with commands like tsrc init and tsrc sync , or simple yaml files, which is much easier than using the git submodule CLI.","title":"Why not git submodule?"},{"location":"faq/#why_not_using_pygit2_or_similar_instead_of_running_git_commands","text":"First off, we do use pygit2 , but only for tests. Second, the pygit2 package depends on a 3rd party C library ( libgit2 ) - and that can cause problems in certain cases. If we can, we prefer using pure-Python libraries for the production code. Finally, we prefer calling git \"porcelain\" commands, both for readability of the source code and ease of debugging (see below).","title":"Why not using pygit2 or similar instead of running git commands?"},{"location":"faq/#why_do_you_hide_which_git_commands_are_run","text":"It's mainly a matter of not cluttering the output. We take care of keeping the output of tsrc both concise, readable and informative. That being said: In case a git command fails, we'll display the full command that was run. If you still need to see all the git commands that are run, we provide a --verbose flag, like so: tsrc --verbose sync","title":"Why do you hide which git commands are run?"},{"location":"faq/#why_argh","text":"Because we need (almost) all of argparse features, but still want to keep the code DRY.","title":"Why argh?"},{"location":"faq/#why_yaml","text":"It's nice to read and write, and we use the excellent ruamel.yaml which even has round-trip support. Also, being Python fans, we don't mind that white space is part of the syntax.","title":"Why YAML?"},{"location":"faq/#why_do_i_have_to_create_a_separate_git_repo_with_just_one_file_in_it","text":"See #235 for why you can't have multiple manifest files in the same repository. Also, note that you can put other files in the repo - for instance, add a CI script that verifies the yaml syntax and checks that all the repos in the manifest can be cloned.","title":"Why do I have to create a separate git repo with just one file in it?"},{"location":"guide/basics/","text":"Creating a manifest \u00b6 tsrc is driven by a manifest file that contains the names and paths of repositories to use. It is a YAML file that looks like this: repos: - url: git@gitlab.local:acme/foo dest: foo - url: git@gitlab.local:acme/bar dest: bar Note The full manifest file format is described in the reference . The manifest must be stored in its own git repository, so that changes in the manifest can be tracked like any other code change. The file must be named manifest.yml Cloning a set of repositories \u00b6 Once the manifest repository is ready, you can run the following commands to create a new workspace: $ mkdir ~/work $ cd work $ tsrc init git@gitlab.local:acme/manifest.git In this example: tsrc will record the manifest URL in .tsrc/config.yml . Then it will clone the manifest inside .tsrc/manifest Then foo will be cloned in <work>/foo using git@gitlab.local/acme/foo.git as the origin remote URL. Similarly, bar will be cloned in <work>/bar using git@gitlab.local:acme/bar.git . Making sure all the repositories are up to date \u00b6 You can update all the repositories by using tsrc sync . First, the manifest clone is updated to match the latest commit on the manifest repository. If new repositories have been added to the manifest, they will be cloned. Finally, all repositories are synced . The sync algorithm looks like this: Run git fetch --tags --prune Check if the repository is on a branch Check if the currently checked out branch matches the one configured in the manifest Check if the repository is dirty Try and run a fast-forward merge Note that: git fetch is always called so that local refs are up-to-date tsrc will simply print an error and move on to the next repository if the fast-forward merge is not possible. That's because tsrc cannot guess what the correct action is, so it prefers doing nothing. It's up to the user to run something like git merge or git rebase .","title":"Basic usage"},{"location":"guide/basics/#creating_a_manifest","text":"tsrc is driven by a manifest file that contains the names and paths of repositories to use. It is a YAML file that looks like this: repos: - url: git@gitlab.local:acme/foo dest: foo - url: git@gitlab.local:acme/bar dest: bar Note The full manifest file format is described in the reference . The manifest must be stored in its own git repository, so that changes in the manifest can be tracked like any other code change. The file must be named manifest.yml","title":"Creating a manifest"},{"location":"guide/basics/#cloning_a_set_of_repositories","text":"Once the manifest repository is ready, you can run the following commands to create a new workspace: $ mkdir ~/work $ cd work $ tsrc init git@gitlab.local:acme/manifest.git In this example: tsrc will record the manifest URL in .tsrc/config.yml . Then it will clone the manifest inside .tsrc/manifest Then foo will be cloned in <work>/foo using git@gitlab.local/acme/foo.git as the origin remote URL. Similarly, bar will be cloned in <work>/bar using git@gitlab.local:acme/bar.git .","title":"Cloning a set of repositories"},{"location":"guide/basics/#making_sure_all_the_repositories_are_up_to_date","text":"You can update all the repositories by using tsrc sync . First, the manifest clone is updated to match the latest commit on the manifest repository. If new repositories have been added to the manifest, they will be cloned. Finally, all repositories are synced . The sync algorithm looks like this: Run git fetch --tags --prune Check if the repository is on a branch Check if the currently checked out branch matches the one configured in the manifest Check if the repository is dirty Try and run a fast-forward merge Note that: git fetch is always called so that local refs are up-to-date tsrc will simply print an error and move on to the next repository if the fast-forward merge is not possible. That's because tsrc cannot guess what the correct action is, so it prefers doing nothing. It's up to the user to run something like git merge or git rebase .","title":"Making sure all the repositories are up to date"},{"location":"guide/groups/","text":"Sometimes it can be necessary to create groups of repositories, especially if the number of repositories grows and if you have people in different teams work on different repositories. Defining groups in the manifest \u00b6 The first step is to edit the manifest.yml file to describe the groups. Here's an example. repos: - {url: git@gitlab.local:acme/one, dest: one} - {url: git@gitlab.local:acme/two, dest: two} - {url: git@gitlab.local:acme/three, dest: three} groups: default: g1: [one, two] g2: [three] Here we define a g1 group that contains repositories named one and two , and a g2 group that contains the repository named three . Using groups in tsrc init \u00b6 If you only need the repositories in the g1 group you can run: tsrc init git@gitlab.local:acme/manifest --group g1 Updating workspace configuration \u00b6 Alternatively, you can edit the .tsrc/config.yml file, like this: manifest_url: git@gitlab.local:acme/manifest.git manifest_branch: master repo_groups: - g1 # <- specify the list of groups to use You can use this technique to change the groups used in a given workspace - the above method using init only works to create new workspaces. The config file contains other configuration options, which should be self-describing - if not, head over to the configurations format section .","title":"Using groups"},{"location":"guide/groups/#defining_groups_in_the_manifest","text":"The first step is to edit the manifest.yml file to describe the groups. Here's an example. repos: - {url: git@gitlab.local:acme/one, dest: one} - {url: git@gitlab.local:acme/two, dest: two} - {url: git@gitlab.local:acme/three, dest: three} groups: default: g1: [one, two] g2: [three] Here we define a g1 group that contains repositories named one and two , and a g2 group that contains the repository named three .","title":"Defining groups in the manifest"},{"location":"guide/groups/#using_groups_in_tsrc_init","text":"If you only need the repositories in the g1 group you can run: tsrc init git@gitlab.local:acme/manifest --group g1","title":"Using groups in tsrc init"},{"location":"guide/groups/#updating_workspace_configuration","text":"Alternatively, you can edit the .tsrc/config.yml file, like this: manifest_url: git@gitlab.local:acme/manifest.git manifest_branch: master repo_groups: - g1 # <- specify the list of groups to use You can use this technique to change the groups used in a given workspace - the above method using init only works to create new workspaces. The config file contains other configuration options, which should be self-describing - if not, head over to the configurations format section .","title":"Updating workspace configuration"},{"location":"ref/cli/","text":"Important note \u00b6 We use the argparse library to parse command line arguments, so the --help messages are always up-to-date, probably more so than this documentation :) General \u00b6 tsrc uses the same \"subcommand\" pattern as git does. Options common to all commands are placed right before the command name. Options after the command name only apply to this command. For instance: $ tsrc --verbose sync $ tsrc init MANIFEST_URL Finally, note that like git , tsrc will walk up the folders hierarchy looking for a .tsrc folder, which means you can run tsrc commands anywhere in your workspace, not just at the top. Global options \u00b6 --verbose show verbose messages -q, --quiet hide everything except errors and warnings --color [always|never|auto] control using color for messages (default 'auto', on if stdout is a terminal) Usage \u00b6 tsrc init MANIFEST_URL [--group GROUP1, GROUP2] [--remote REMOTE] Initializes a new workspace. MANIFEST_URL should be a git URL containing a valid manifest.yml file. The -g,--groups option can be used to specify a list of groups to use when cloning repositories. The -s,--shallow option can be used to make shallow clone of all repositories. If you want to add or remove a group in your workspace, you can edit the configuration file in <workspace>/.tsrc/config.yml The -r,--remote option can be used to set a fix remote to use when cloning and syncing the repositories. If this flag is set, the remote from the manifest with the given name will be used for all repos. It is an error if a repo does not have this remote specified. tsrc foreach -- command --opt1 arg1 Runs command --opt1 arg1 in every repository, and report failures at the end. Note the -- token to separate options for command from options for tsrc . tsrc foreach -c 'command --opt1 arg1' Ditto, but uses a shell ( /bin/sh on Linux or macOS, cmd.exe on Windows). tsrc log --from FROM [--to TO] Display a summary of all changes since FROM (should be a tag), to TO (defaulting to master ). Note that if no changes are found, the repository will not be displayed at all. tsrc status Displays a summary of the status of your workspace: Shows dirty repositories Shows repositories not on the expected branch tsrc sync Updates all the repositories and shows a summary at the end. tsrc version Displays tsrc version number, along additional data if run from a git clone. tsrc apply-manifest PATH Apply changes from the manifest file located at PATH . Useful to check changes in the manifest before publishing them to the manifest repository.","title":"Command line usage"},{"location":"ref/cli/#important_note","text":"We use the argparse library to parse command line arguments, so the --help messages are always up-to-date, probably more so than this documentation :)","title":"Important note"},{"location":"ref/cli/#general","text":"tsrc uses the same \"subcommand\" pattern as git does. Options common to all commands are placed right before the command name. Options after the command name only apply to this command. For instance: $ tsrc --verbose sync $ tsrc init MANIFEST_URL Finally, note that like git , tsrc will walk up the folders hierarchy looking for a .tsrc folder, which means you can run tsrc commands anywhere in your workspace, not just at the top.","title":"General"},{"location":"ref/cli/#global_options","text":"--verbose show verbose messages -q, --quiet hide everything except errors and warnings --color [always|never|auto] control using color for messages (default 'auto', on if stdout is a terminal)","title":"Global options"},{"location":"ref/cli/#usage","text":"tsrc init MANIFEST_URL [--group GROUP1, GROUP2] [--remote REMOTE] Initializes a new workspace. MANIFEST_URL should be a git URL containing a valid manifest.yml file. The -g,--groups option can be used to specify a list of groups to use when cloning repositories. The -s,--shallow option can be used to make shallow clone of all repositories. If you want to add or remove a group in your workspace, you can edit the configuration file in <workspace>/.tsrc/config.yml The -r,--remote option can be used to set a fix remote to use when cloning and syncing the repositories. If this flag is set, the remote from the manifest with the given name will be used for all repos. It is an error if a repo does not have this remote specified. tsrc foreach -- command --opt1 arg1 Runs command --opt1 arg1 in every repository, and report failures at the end. Note the -- token to separate options for command from options for tsrc . tsrc foreach -c 'command --opt1 arg1' Ditto, but uses a shell ( /bin/sh on Linux or macOS, cmd.exe on Windows). tsrc log --from FROM [--to TO] Display a summary of all changes since FROM (should be a tag), to TO (defaulting to master ). Note that if no changes are found, the repository will not be displayed at all. tsrc status Displays a summary of the status of your workspace: Shows dirty repositories Shows repositories not on the expected branch tsrc sync Updates all the repositories and shows a summary at the end. tsrc version Displays tsrc version number, along additional data if run from a git clone. tsrc apply-manifest PATH Apply changes from the manifest file located at PATH . Useful to check changes in the manifest before publishing them to the manifest repository.","title":"Usage"},{"location":"ref/formats/","text":"All configuration files use YAML syntax. manifest.yml \u00b6 The manifest is always parsed as a dictionary. Top fields \u00b6 repos (required): list of repositories to clone groups (optional): list of groups repos \u00b6 Each repository is also a dictionary, containing: Either: url if you just need one remote named origin A list of remotes with a name and url . In that case, the first remote will be used for cloning the repository. dest (required): relative path of the repository in the workspace branch (optional): The branch to use when cloning the repository (defaults to master ) tag (optional): When running tsrc init : Project will be cloned at the provided tag. When running tsrc sync : If the project is clean, project will be reset to the given tag, else a warning message will be printed. sha1 (optional): When running tsrc init : Project will be cloned, and then reset to the given sha1. When running tsrc sync : If the project is clean, project will be reset to the given sha1, else a warning message will be printed. copy (optional): A list of dictionaries with file and dest keys. symlink (optional): A list of dictionaries with source and target keys. Here's a full example: repos: - url: git@gitlab.local:proj1/foo dest: foo branch: next - remotes: - name: origin url: git@gitlab.local:proj1/bar - name: upstream url: git@github.com:user/bar dest: bar branch: master sha1: ad2b68539c78e749a372414165acdf2a1bb68203 - url: git@gitlab.local:proj1/app dest: app tag: v0.1 copy: - file: top.cmake dest: CMakeLists.txt - file: .clangformat symlink: - source: app/some_file target: ../foo/some_file In this example: First, proj1/foo will be cloned into <workspace>/foo using the next branch. Then, proj1/bar will be cloned into <workspace>/bar using the master branch, and reset to ad2b68539c78e749a372414165acdf2a1bb68203 . Finally: proj1/app will be cloned into <workspace>/app using the v0.1 tag, top.cmake will be copied from proj1/app/top.cmake to <workspace>/CMakeLists.txt , .clang-format will be copied from proj1/app/ to <workspace>/ , and a symlink will be created from <workspace>/app/some_file to <workspace>/foo/some_file . Note that copy only works with files, not directories. The source path for a symbolic link is relative to the top-level <workspace> , whereas each target path is then relative to the associated source. (This path relationship is essentially identical to how ln -s works on the command line in Unix-like environments.) Multiple symlinks can be specified; each must specify a source and target. Symlink creation is supported on all operating systems, but creation of NTFS symlinks on Windows requires that the current user have appropriate security policy permission (SeCreateSymbolicLinkPrivilege). By default, only administrators have that privilege set, although newer versions of Windows 10 support a Developer Mode that permits unprivileged accounts to create symlinks. Note that Cygwin running on Windows defaults to creating links via Windows shortcuts, which do not require any special privileges. (Cygwin's symlink behavior can be user controlled with the winsymlinks setting in the CYGWIN environment variable.) groups \u00b6 The groups section lists the groups by name. Each group should have a repos field containing a list of repositories (only repositories defined in the repos section are allowed). The groups can optionally include other groups, with a includes field which should be a list of existing group names. The group named default , if it exists, will be used to know which repositories to clone when using tsrc init and the --group command line argument is not used. Example: repos: - dest: a url: .. - dest: b url: .. - dest: bar url: .. - dest: baz url: .. groups: default: repos: [a, b] foo: repos: [bar, baz] includes: [default] $ tsrc init <manifest_url> # Clones a, b $ tsrc init <manifest_url> --group foo # Clones a, b, bar and baz Note that tsrc init records the names of the groups it was invoked with, so that tsrc sync re-uses them later on. This means that if you want to change the groups used, you must re-run tsrc init with the new group list. Workspace configuration file \u00b6 The workspace configuration lies in <workspace>/.tsrc/config.yml . It is created by tsrc init then read by tsrc sync and other commands. It can be freely edited by hand. Here's an example: manifest_url: git@acme.corp:manifest.git manifest_branch: master shallow_clones: false repo_groups: - default clone_all_repos: false manifest_url : an git URL containing a manifest.yml file manifest_branch : the branch to use when updating the local manifest (e.g, the first step of tsrc sync ) shallow_clones : whether to use only shallow clones when cloning missing repositories repo_groups : the list of groups to use - every mentioned group must be present in the manifest.yml file (see above) clone_all_repos : whether to ignore groups entirely and clone every repository from the manifest instead","title":"Configuration files formats"},{"location":"ref/formats/#manifestyml","text":"The manifest is always parsed as a dictionary.","title":"manifest.yml"},{"location":"ref/formats/#top_fields","text":"repos (required): list of repositories to clone groups (optional): list of groups","title":"Top fields"},{"location":"ref/formats/#repos","text":"Each repository is also a dictionary, containing: Either: url if you just need one remote named origin A list of remotes with a name and url . In that case, the first remote will be used for cloning the repository. dest (required): relative path of the repository in the workspace branch (optional): The branch to use when cloning the repository (defaults to master ) tag (optional): When running tsrc init : Project will be cloned at the provided tag. When running tsrc sync : If the project is clean, project will be reset to the given tag, else a warning message will be printed. sha1 (optional): When running tsrc init : Project will be cloned, and then reset to the given sha1. When running tsrc sync : If the project is clean, project will be reset to the given sha1, else a warning message will be printed. copy (optional): A list of dictionaries with file and dest keys. symlink (optional): A list of dictionaries with source and target keys. Here's a full example: repos: - url: git@gitlab.local:proj1/foo dest: foo branch: next - remotes: - name: origin url: git@gitlab.local:proj1/bar - name: upstream url: git@github.com:user/bar dest: bar branch: master sha1: ad2b68539c78e749a372414165acdf2a1bb68203 - url: git@gitlab.local:proj1/app dest: app tag: v0.1 copy: - file: top.cmake dest: CMakeLists.txt - file: .clangformat symlink: - source: app/some_file target: ../foo/some_file In this example: First, proj1/foo will be cloned into <workspace>/foo using the next branch. Then, proj1/bar will be cloned into <workspace>/bar using the master branch, and reset to ad2b68539c78e749a372414165acdf2a1bb68203 . Finally: proj1/app will be cloned into <workspace>/app using the v0.1 tag, top.cmake will be copied from proj1/app/top.cmake to <workspace>/CMakeLists.txt , .clang-format will be copied from proj1/app/ to <workspace>/ , and a symlink will be created from <workspace>/app/some_file to <workspace>/foo/some_file . Note that copy only works with files, not directories. The source path for a symbolic link is relative to the top-level <workspace> , whereas each target path is then relative to the associated source. (This path relationship is essentially identical to how ln -s works on the command line in Unix-like environments.) Multiple symlinks can be specified; each must specify a source and target. Symlink creation is supported on all operating systems, but creation of NTFS symlinks on Windows requires that the current user have appropriate security policy permission (SeCreateSymbolicLinkPrivilege). By default, only administrators have that privilege set, although newer versions of Windows 10 support a Developer Mode that permits unprivileged accounts to create symlinks. Note that Cygwin running on Windows defaults to creating links via Windows shortcuts, which do not require any special privileges. (Cygwin's symlink behavior can be user controlled with the winsymlinks setting in the CYGWIN environment variable.)","title":"repos"},{"location":"ref/formats/#groups","text":"The groups section lists the groups by name. Each group should have a repos field containing a list of repositories (only repositories defined in the repos section are allowed). The groups can optionally include other groups, with a includes field which should be a list of existing group names. The group named default , if it exists, will be used to know which repositories to clone when using tsrc init and the --group command line argument is not used. Example: repos: - dest: a url: .. - dest: b url: .. - dest: bar url: .. - dest: baz url: .. groups: default: repos: [a, b] foo: repos: [bar, baz] includes: [default] $ tsrc init <manifest_url> # Clones a, b $ tsrc init <manifest_url> --group foo # Clones a, b, bar and baz Note that tsrc init records the names of the groups it was invoked with, so that tsrc sync re-uses them later on. This means that if you want to change the groups used, you must re-run tsrc init with the new group list.","title":"groups"},{"location":"ref/formats/#workspace_configuration_file","text":"The workspace configuration lies in <workspace>/.tsrc/config.yml . It is created by tsrc init then read by tsrc sync and other commands. It can be freely edited by hand. Here's an example: manifest_url: git@acme.corp:manifest.git manifest_branch: master shallow_clones: false repo_groups: - default clone_all_repos: false manifest_url : an git URL containing a manifest.yml file manifest_branch : the branch to use when updating the local manifest (e.g, the first step of tsrc sync ) shallow_clones : whether to use only shallow clones when cloning missing repositories repo_groups : the list of groups to use - every mentioned group must be present in the manifest.yml file (see above) clone_all_repos : whether to ignore groups entirely and clone every repository from the manifest instead","title":"Workspace configuration file"}]}